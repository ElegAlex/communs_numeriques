// Storage Helper (fallback for sandboxed environments)
const storage = {
    available: (() => {
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            return true;
        } catch(e) {
            return false;
        }
    })(),
    
    getItem: function(key) {
        if (this.available) {
            return localStorage.getItem(key);
        }
        return null;
    },
    
    setItem: function(key, value) {
        if (this.available) {
            localStorage.setItem(key, value);
        }
    }
};

// Theme Toggle
const themeToggle = document.getElementById('theme-toggle');
const currentTheme = storage.getItem('theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
document.documentElement.setAttribute('data-theme', currentTheme);

const sunIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>`;
const moonIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`;

function updateThemeIcon() {
    if (document.documentElement.getAttribute('data-theme') === 'dark') {
        themeToggle.innerHTML = sunIcon;
    } else {
        themeToggle.innerHTML = moonIcon;
    }
}
updateThemeIcon(); // Call it once at load

themeToggle.addEventListener('click', async () => {
    const currentDocTheme = document.documentElement.getAttribute('data-theme');
    const newDocTheme = currentDocTheme === 'dark' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', newDocTheme);
    storage.setItem('theme', newDocTheme);
    updateThemeIcon();

    // Mettre à jour le thème Mermaid
    mermaid.initialize({ 
        startOnLoad: false,
        theme: newDocTheme === 'dark' ? 'dark' : 'default'
    });
    
    // Re-rendre les diagrammes Mermaid avec le nouveau thème
    const diagrams = document.querySelectorAll('.mermaid');
    if (diagrams.length > 0) {
        mermaid.run({
            querySelector: '.mermaid'
        });
    }
});

// Table of Contents Toggle
const tocToggle = document.getElementById('toc-toggle');
const navSidebar = document.getElementById('nav-sidebar');
const mainContent = document.getElementById('main-content');
const HEADER_HEIGHT = 80; 

tocToggle.addEventListener('click', () => {
    navSidebar.classList.toggle('open');
    if (window.innerWidth > 1200) { 
        mainContent.classList.toggle('with-sidebar', navSidebar.classList.contains('open'));
    }
});

// Reading Progress
const readingProgress = document.getElementById('reading-progress');
let articleContentSectionForProgress; 

function updateReadingProgress() {
    if (!articleContentSectionForProgress) return;

    const contentHeight = articleContentSectionForProgress.offsetHeight;
    const articleHeaderHeight = document.querySelector('.article-header')?.offsetHeight || 0;
    
    const viewportHeight = window.innerHeight - HEADER_HEIGHT;
    const scrollableHeight = contentHeight - viewportHeight;
    
    const scrollTopRelativeToDocument = window.pageYOffset;
    const articleContentStartOffset = articleContentSectionForProgress.offsetTop - HEADER_HEIGHT;
    let currentScrollInContent = scrollTopRelativeToDocument - articleContentStartOffset;
   
    let progress = 0;
    if (scrollableHeight > 0) {
         progress = (currentScrollInContent / scrollableHeight) * 100;
    } else if (currentScrollInContent >= 0 && contentHeight > 0) { 
        progress = 100;
    }
    
    readingProgress.style.width = Math.min(Math.max(progress, 0), 100) + '%';
}

// Active TOC Link
let tocLinks = []; 
let sections = []; 

function updateActiveTocLink() {
    if (!sections.length || !tocLinks.length) return;

    let currentSectionId = '';
    const scrollPos = window.pageYOffset + HEADER_HEIGHT + 30; 

    for (let i = sections.length - 1; i >= 0; i--) {
        if (sections[i].offsetTop <= scrollPos) {
            currentSectionId = sections[i].id;
            break;
        }
    }
    
    tocLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === '#' + currentSectionId) {
            link.classList.add('active');
            if (navSidebar.classList.contains('open') && navSidebar.offsetWidth > 0 && navSidebar.offsetHeight > 0) { 
                 link.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
            }
        }
    });
}

// Back to Top
const backToTop = document.getElementById('back-to-top');

function toggleBackToTop() {
    if (window.pageYOffset > 300) {
        backToTop.classList.remove('hidden');
    } else {
        backToTop.classList.add('hidden');
    }
}

backToTop.addEventListener('click', () => {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
});

// Close sidebar when clicking outside or on a link
document.addEventListener('click', (e) => {
    if (navSidebar.classList.contains('open')) {
        if (!navSidebar.contains(e.target) && !tocToggle.contains(e.target)) {
            closeNavSidebar();
        }
        if (e.target.classList.contains('toc-link') || e.target.closest('.toc-link')) {
             if (window.innerWidth <= 768) { 
                closeNavSidebar();
             }
        }
    }
});

function closeNavSidebar() {
    navSidebar.classList.remove('open');
    if (window.innerWidth > 1200) { 
        mainContent.classList.remove('with-sidebar');
    }
}

// Smooth scroll for anchor links from TOC
function initializeTocLinkSmoothScroll() {
    document.querySelectorAll('#toc-list-container .toc-link[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const targetId = this.getAttribute('href');
            const targetElement = document.querySelector(targetId);
            if (targetElement) {
                const elementPosition = targetElement.getBoundingClientRect().top + window.pageYOffset;
                const offsetPosition = elementPosition - HEADER_HEIGHT - 15; 

                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
                 if (window.innerWidth <= 768 && navSidebar.classList.contains('open')) {
                    closeNavSidebar();
                }
            }
        });
    });
}

function handleResize() {
    if (window.innerWidth <= 1200) {
        mainContent.classList.remove('with-sidebar');
    } else { 
        if (navSidebar.classList.contains('open')) {
             mainContent.classList.add('with-sidebar');
        } else {
            mainContent.classList.remove('with-sidebar');
        }
    }
}

// Debounce function
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

const debouncedUpdateReadingProgress = debounce(updateReadingProgress, 50);
const debouncedUpdateActiveTocLink = debounce(updateActiveTocLink, 50);
const debouncedHandleResize = debounce(handleResize, 100);

window.addEventListener('scroll', () => {
    debouncedUpdateReadingProgress();
    debouncedUpdateActiveTocLink();
    toggleBackToTop();
});
window.addEventListener('resize', debouncedHandleResize);

// --- Markdown to HTML Conversion Logic ---
const markdownContent = `
## **Introduction**

La transformation numérique de l'administration publique s'impose aujourd'hui comme un impératif, porteur de promesses autant que de tensions. Cette mutation profonde, loin d'être une simple adaptation technologique, interroge les fondements mêmes de l'action publique et de ses modalités de gouvernance. Dans ce contexte de bouleversements, le paradigme des communs numériques émerge comme une voie alternative prometteuse, bien que sa définition et ses implications pratiques fassent encore l'objet de débats et d'interprétations variées au sein même de la sphère publique, susceptible de renouveler les approches traditionnelles de gestion des systèmes d'information publics. Pourtant, malgré leur potentiel transformateur reconnu, l'intégration durable de ces communs dans les structures administratives demeure un défi complexe, soulevant la question cruciale de leur institutionnalisation.

### **La transformation numérique de l'administration publique, un impératif sous tensions**

L'administration publique française, à l'instar de ses homologues internationaux, est engagée dans une profonde mutation sous l'effet du numérique. Cette transformation s'articule autour d'une double ambition. D'une part, la recherche d'efficacité opérationnelle guide les efforts de modernisation. Les technologies numériques promettent l'automatisation des processus, la rationalisation des flux de travail et la réalisation d'économies d'échelle substantielles. Cette quête de performance s'inscrit dans la continuité des réformes managériales publiques, du New Public Management aux approches plus récentes de Digital Era Governance, comme l'analysent Cordella et Paletti (2019) dans leur étude sur le concept de gouvernement plateforme.

D'autre part, la transformation numérique vise à accroître ce que Benington (2007) nomme la valeur publique. Il s'agit de la capacité de l'administration à répondre aux besoins sociétaux et à générer des bénéfices collectifs au-delà de la simple efficience économique, une valeur dont la définition même et les modalités de création par les communs peuvent faire l'objet de tensions entre les attentes administratives, citoyennes et communautaires. Les citoyens attendent désormais des services publics accessibles en continu, personnalisés et intuitifs, à l'image de leurs expériences dans le secteur privé. L'émergence du concept d'État plateforme, où l'administration met à disposition des ressources numériques (données, interfaces de programmation) pour stimuler l'innovation externe, illustre cette ambition renouvelée.

Cependant, cette transformation se heurte à des obstacles structurels considérables. Lindgren et van Veenstra (2018) identifient dans leur analyse de la transformation digitale gouvernementale plusieurs limites majeures, tel que l'héritage de systèmes d'information vieillissants, le fonctionnement en silos organisationnels qui entrave l'interopérabilité et les contraintes budgétaires qui limitent les investissements nécessaires. Ces contraintes techniques s'articulent avec des résistances culturelles et organisationnelles profondes, parfois au sein même des directions chargées de porter cette transformation. Comme le soulignent Bjerke-Busch et Aspelund (2021) dans leur étude sur les barrières à la transformation digitale du secteur public, la culture administrative traditionnelle, caractérisée par l'aversion au risque, les structures hiérarchiques rigides et les routines établies, constitue souvent un frein plus important que les limitations technologiques.

À ces tensions internes s'ajoutent de forts enjeux sociétaux. La dématérialisation des services publics, si elle promet efficacité et accessibilité, soulève la question de l'équité d'accès. Onyango et Ondiek (2021) mettent en garde contre le risque d'exclusion numérique qui pourrait transformer la promesse d'universalité du service public en facteur d'inégalité. Par ailleurs, la gestion de volumes croissants de données personnelles et sensibles exacerbe les problèmes et risques en termes de sécurité, de protection de la vie privée et, plus fondamentalement, de souveraineté numérique. C'est une préoccupation particulièrement aiguë face à la dépendance à l'égard de fournisseurs technologiques non européens [Pohle et Thiel, 2020], une quête de souveraineté elle-même complexe, naviguant entre impératifs de contrôle étatique et la nature potentiellement ouverte et distribuée de certains communs.

Cette situation révèle une tension fondamentale. Alors que la transformation numérique s'inspire souvent de modèles issus du secteur privé, l'administration doit opérer cette mutation dans un cadre institutionnel radicalement différent. Les contraintes du droit public, notamment le code des marchés publics analysé par Mitchell (2022), les obligations de service public (continuité, égalité, adaptabilité), et la nécessité de rendre des comptes démocratiquement créent un ensemble de contraintes spécifiques. Comme le note Crozier (1963) dans son analyse du phénomène bureaucratique, les organisations publiques sont structurées pour garantir la stabilité et l'égalité de traitement plutôt que pour favoriser l'innovation et l'adaptation rapide.

### **Les limites des approches conventionnelles et l'émergence d'une alternative**

Face à ce contexte, les approches conventionnelles de gestion des systèmes d'information publics révèlent leurs limites structurelles. Le développement fragmenté de solutions informatiques au sein de chaque direction ou organisme engendre ce que Sadeghi et al. (2023) décrivent comme un paysage d'îlots technologiques, des systèmes isolés qui peinent à communiquer entre eux et entravent la mise en œuvre de services publics véritablement intégrés. Cette fragmentation nuit non seulement à l'efficacité opérationnelle mais compromet également la capacité de l'administration à offrir une expérience cohérente aux usagers.

La dépendance à l'égard de solutions propriétaires constitue un second écueil majeur. Les risques du verrouillage fournisseur ("vendor lock-in") mettent en lumière les limites de la flexibilité technologique, qui augmentent les coûts à long terme et, plus problématiquement, réduisent le contrôle de l'administration sur ses propres outils numériques [Cox, 2019], bien que l'alternative des communs numériques ne soit pas exempte de nouvelles formes de dépendances potentielles. Cette dépendance soulève des questions de souveraineté numérique particulièrement sensibles dans le contexte géopolitique actuel [Fratini et al., 2024].

Dans ce contexte, le paradigme des communs numériques émerge comme une alternative conceptuellement riche et pratiquement prometteuse. Dulong de Rosnay et al. (2020) définissent les communs numériques comme des ressources informationnelles partagées, gérées collectivement par une communauté selon des règles qu'elle définit elle-même. Cette approche, bien que séduisante, masque parfois la diversité des pratiques et des interprétations du terme "commun" au sein des administrations, où la dimension "communautaire" ou la "gouvernance partagée" peuvent être plus ou moins prégnantes. Cette définition s'inscrit dans la lignée des travaux fondateurs d'Ostrom (1990) sur les communs naturels, tout en reconnaissant les spécificités du numérique, notamment la nature non-rivale de l'information qui, contrairement aux ressources naturelles, ne se dégrade pas avec l'usage.

Le passage du paradigme des communs naturels aux communs numériques a été théorisé par plusieurs auteurs. Benkler (2006) dans "The Wealth of Networks" démontre comment la production par les pairs basée sur les communs constitue un nouveau mode d'organisation économique et sociale. Coriat (2011) souligne la différence fondamentale entre communs fonciers et communs informationnels. Si les premiers sont menacés par la surexploitation, les seconds risquent plutôt la sous-production faute de contributions suffisantes, un défi auquel l'administration publique pourrait apporter une réponse en stimulant et soutenant cette production. Cette spécificité appelle des modes de gouvernance adaptés, comme dans l'application des principes d'Ostrom aux écosystèmes de données ouvertes [Linåker et Runeson, 2022].

La pertinence de ce paradigme pour l'administration publique est multiple et déjà partiellement démontrée par des initiatives concrètes. L'usage croissant de logiciels libres dans les administrations européennes illustre les bénéfices potentiels que sont la réduction des coûts, la mutualisation des développements, ou la flexibilité accrue et moindre dépendance aux fournisseurs [Linåker et al., 2023]. La mise en place de plateformes de données ouvertes démontre comment les communs de données peuvent stimuler l'innovation et la transparence [van Loenen et al., 2021]. Plus fondamentalement, les communs numériques offrent un modèle de gouvernance qui peut s'aligner avec les valeurs du service public, telles que la transparence, la participation et la défense du bien commun [Abiteboul et Bancilhon, 2024], bien que cet alignement ne soit pas automatique et puisse révéler des conflits de logiques institutionnelles.

Cependant, adopter les communs numériques ne se résume pas à un simple choix technique ou économique. Comme le souligne Shulz (2024) dans son analyse du passage de la coproduction à la communalisation des biens et services publics numériques, il s'agit d'un changement de paradigme de gouvernance. Là où l'approche traditionnelle repose sur le contrôle hiérarchique et les relations contractuelles, les communs impliquent une gestion distribuée, des processus de décision participatifs et une ouverture aux contributions externes. Cette transformation touche aux fondements mêmes de l'organisation administrative, au sein desquelles les résistances peuvent être fortes comme l'illustre la trajectoire de la Base Adresse Nationale, passée d'un commun numérique collaboratif à un modèle plus centralisé sous contrôle étatique [Shulz, 2021].

### **L'institutionnalisation des communs numériques, l'enjeu central**

Si les bénéfices potentiels des communs numériques sont largement documentés, leur intégration effective et durable dans l'administration demeure problématique. L'enthousiasme pour ces approches collaboratives se heurte souvent à la réalité des contraintes institutionnelles. Marsan et al. (2012) s'interrogent ainsi sur le degré réel d'institutionnalisation de l'open source dans les organisations, concluant à une adoption souvent superficielle et opportuniste plutôt qu'à une véritable transformation des pratiques.

Pour analyser cet enjeu d'ancrage durable, cette recherche mobilise le concept sociologique d'institutionnalisation. Ainsi, les institutions sont décrites comme des structures sociales qui ont atteint un haut degré de résilience, reposant sur trois piliers [Scott, 2014] :
- le régulatif (règles et sanctions),
- le normatif (valeurs et attentes),
- le culturel-cognitif (schémas de pensée partagés).
L'institutionnalisation désigne ainsi le processus par lequel des pratiques acquièrent progressivement ces caractéristiques institutionnelles, devenant "taken for granted" [Meyer et Rowan, 1977]. Ce processus est d'autant plus délicat que les communs numériques, par leur nature souvent distribuée et leur gouvernance participative, peuvent entrer en tension avec les mécanismes traditionnels de contrôle et de décision de l'administration.

Appliquée aux communs numériques, l'institutionnalisation signifie leur passage d'initiatives expérimentales ou marginales à des approches standards et légitimes dans la gestion des ressources numériques publiques. Ce processus est particulièrement complexe dans le contexte administratif où, comme le montrent DiMaggio et Powell (1983), les organisations publiques subissent des pressions isomorphiques (coercitives, mimétiques et normatives) qui tendent à homogénéiser leurs pratiques selon les modèles dominants. L'introduction des communs représente donc une gageure face aux logiques institutionnelles établies.

Lawrence et Suddaby (2006) enrichissent cette perspective en introduisant le concept de travail institutionnel, qui se caractérise par les efforts intentionnels des acteurs pour créer, maintenir ou transformer les institutions. Cette approche reconnaît l'agence des acteurs, qu'ils soient agents publics "entrepreneurs", managers éclairés, communautés externes ou structures de soutien spécialisées, dans les processus de changement institutionnel, dont les intérêts et stratégies peuvent converger ou diverger. Elle est particulièrement pertinente pour comprendre comment ces acteurs peuvent promouvoir l'adoption des communs numériques malgré les résistances structurelles [Ben Slimane, 2019].

La problématique qui guide ce mémoire est donc : Quels sont les facteurs d'institutionnalisation des communs numériques dans l'administration publique ?

\`\`\`mermaid
graph LR
    A[Innovation / Pratique Émergente] --> B(Habitualisation / Routinisation);
    B --> C(Objectivation);
    C --> D{Légitimation};
    D -- Piliers Régulatif, Normatif, Culturel-Cognitif --> E(Sédimentation / Naturalisation);
    E --> F["Taken for granted"];
\`\`\`

L'émergence de cette question provient notamment des lacunes de la littérature académique sur le sujet. Si des travaux existent sur la transformation numérique de l'État [Jerab, 2024], sur les communs numériques [El Yahyaoui, 2022], et sur les processus d'institutionnalisation [Lawrence et al., 2009], peu d'études se situent spécifiquement à leur intersection.

### **Structure et ambitions du mémoire**

Pour répondre à cette problématique, ce mémoire s'articule en trois parties complémentaires.

La première partie établit le cadre conceptuel nécessaire à l'analyse. Elle examine d'abord ce qu'implique la recherche de performance numérique dans l'administration publique, en analysant les impératifs de modernisation, les limites des systèmes actuels et les spécificités du contexte administratif français. Elle explore ensuite le paradigme des communs numériques, depuis ses fondements théoriques jusqu'à sa pertinence pour le secteur public. Enfin, elle approfondit le concept d'institutionnalisation en mobilisant les théories néo-institutionnelles et du travail institutionnel, articulées avec les principes de gouvernance des communs d'Ostrom.
`;

function slugify(text) {
    if (!text) return '';
    return text.toString().toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^\w-]+/g, '')
        .replace(/--+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '');
}

function parseMarkdown(markdown) {
    const lines = markdown.trim().split('\n');
    let htmlOutput = '';
    let tocHtml = '';
    
    const tocStructure = [];
    let listLevel = 0;
    let inList = false;
    let inTable = false;
    let tableHeader = [];
    let tableAlignments = [];

    function getHeadingText(line, levelMarker) {
        let text = line.substring(levelMarker.length).trim();
        if (text.startsWith('**') && text.endsWith('**')) {
            return text.substring(2, text.length - 2);
        }
        return text;
    }
    
    function getCleanHeadingTextForSlug(line, levelMarker) {
        let text = line.substring(levelMarker.length).trim();
        if (text.startsWith('**') && text.endsWith('**')) {
            text = text.substring(2, text.length - 2);
        }
        text = text.replace(/^(\d+(\.\d+)*\.?\s*?[:\-\s]*?|\w+\s\w+\s*?[:\-\s]*?)\s*/, '');
        return text;
    }

    function appendToToc(level, text, id) {
        let displayTitle = text;
        if (displayTitle.toUpperCase().startsWith("PARTIE ")) {
            const aTitle = displayTitle.split(':')[0];
            const bTitle = displayTitle.split(':')[1];
            if (bTitle && bTitle.length > 50) {
                displayTitle = aTitle + ": " + bTitle.substring(0,50).trim() + "...";
            }
        }

        while (tocStructure.length > level) {
            tocStructure.pop();
            tocHtml += '</ul></li>';
        }
        while (tocStructure.length < level) {
            tocStructure.push(true);
            tocHtml += (tocStructure.length > 1 ? '<ul class="toc-list">' : '');
        }
        tocHtml += `<li><a class="toc-link" href="#${id}">${displayTitle.replace(/<[^>]*>?/gm, '')}</a>`;
    }
    
    function closeAllTocLevels() {
        while (tocStructure.length > 0) {
            tocStructure.pop();
            tocHtml += '</ul></li>';
        }
    }

    function closeListIfNeeded() {
        if (inList) {
            htmlOutput += (listLevel === 1 ? '</ul>' : '</ol>');
            inList = false;
            listLevel = 0;
        }
    }
    
    function closeTableIfNeeded() {
        if (inTable) {
            htmlOutput += '</tbody></table></div>';
            inTable = false;
            tableHeader = [];
            tableAlignments = [];
        }
    }

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];

        // Handle Headings
        if (line.startsWith('# ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '# ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '# ');
            const id = slugify(cleanTextForSlug) || `partie-${i}`;
            htmlOutput += `<h2 id="${id}">${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</h2>`;
            appendToToc(0, text, id);
        } else if (line.startsWith('## ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '## ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '## ');
            const id = slugify(cleanTextForSlug) || `section-${i}`;
            htmlOutput += `<h3 id="${id}">${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</h3>`;
            appendToToc(1, text, id);
        } else if (line.startsWith('### ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '### ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '### ');
            const id = slugify(cleanTextForSlug) || `subsection-${i}`;
            htmlOutput += `<h4 id="${id}">${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</h4>`;
            appendToToc(2, text, id);
        } else if (line.startsWith('#### ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '#### ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '#### ');
            const id = slugify(cleanTextForSlug) || `subsubsection-${i}`;
            htmlOutput += `<h5 id="${id}">${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</h5>`;
            appendToToc(3, text, id);
        } else if (line.startsWith('##### ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '##### ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '##### ');
            const id = slugify(cleanTextForSlug) || `minisubsection-${i}`;
            htmlOutput += `<h6 id="${id}">${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</h6>`;
            appendToToc(4, text, id);
        } else if (line.startsWith('###### ')) {
            closeListIfNeeded(); closeTableIfNeeded();
            const text = getHeadingText(line, '###### ');
            const cleanTextForSlug = getCleanHeadingTextForSlug(line, '###### ');
            const id = slugify(cleanTextForSlug) || `tinysubsection-${i}`;
            htmlOutput += `<h6 id="${id}"><em>${text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</em></h6>`;
            appendToToc(5, text, id);
        }
        // Handle Mermaid diagrams - CORRECTION ICI
        else if (line.trim() === '```mermaid') {
            closeListIfNeeded(); closeTableIfNeeded();
            htmlOutput += '<div class="mermaid-diagram-container"><div class="mermaid">';
            let j = i + 1;
            while (j < lines.length && lines[j].trim() !== '```') {
                htmlOutput += lines[j] + '\n';
                j++;
            }
            htmlOutput += '</div></div>';
            i = j; // Skip mermaid block
        }
        else if (line.startsWith('> **Attention**') || line.startsWith('> Attention')) {
            closeListIfNeeded(); closeTableIfNeeded();
            htmlOutput += '<blockquote class="admonition warning">';
            const title = line.substring(line.indexOf('Attention'));
            htmlOutput += `<p class="admonition-title">${title}</p>`;
            let j = i + 1;
            while(j < lines.length && lines[j].startsWith('> ')) {
                htmlOutput += `<p>${lines[j].substring(2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`;
                j++;
            }
            htmlOutput += '</blockquote>';
            i = j - 1;
        }
        else if (line.startsWith('# Attention : cette section sera largement reprise')) {
            closeListIfNeeded(); closeTableIfNeeded();
            htmlOutput += '<blockquote class="admonition warning">';
            htmlOutput += '<p class="admonition-title">Attention</p>';
            htmlOutput += `<p>${line.substring(2)}</p>`;
            htmlOutput += '</blockquote>';
        }
        // Handle Tables
        else if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
            closeListIfNeeded();
            if (!inTable) {
                htmlOutput += '<div class="table-responsive-wrapper"><table class="styled-table">';
                inTable = true;
                tableHeader = line.trim().slice(1, -1).split('|').map(s => s.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'));
                htmlOutput += '<thead><tr>';
                tableHeader.forEach(h => htmlOutput += `<th>${h}</th>`);
                htmlOutput += '</tr></thead><tbody>';

                if (lines[i+1] && lines[i+1].trim().match(/^\|(:?-+:?\|)+$/)) {
                    tableAlignments = lines[i+1].trim().slice(1, -1).split('|').map(s => {
                        const trimmed = s.trim();
                        if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';
                        if (trimmed.startsWith(':')) return 'left';
                        if (trimmed.endsWith(':')) return 'right';
                        return 'left';
                    });
                    i++;
                }
            } else {
                const rowData = line.trim().slice(1, -1).split('|').map(s => s.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'));
                htmlOutput += '<tr>';
                rowData.forEach((cell, k) => {
                    let style = '';
                    if(tableAlignments[k]) style = ` style="text-align: ${tableAlignments[k]}"`;
                    if (cell.includes('<br>- ')) {
                        const items = cell.split('<br>- ').map(item => item.trim()).filter(item => item);
                        if (items.length > 0) {
                            cell = '<ul>' + items.map(item => `<li>${item}</li>`).join('') + '</ul>';
                        }
                    }
                    htmlOutput += `<td${style}>${cell}</td>`;
                });
                htmlOutput += '</tr>';
            }
        }
        // Handle lists
        else if (line.startsWith('- ') || line.startsWith('* ')) {
            closeTableIfNeeded();
            if (!inList || listLevel !== 1) {
                closeListIfNeeded();
                htmlOutput += '<ul>';
                inList = true;
                listLevel = 1;
            }
            htmlOutput += `<li>${line.substring(2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</li>`;
        } else if (line.match(/^\d+\.\s/)) {
            closeTableIfNeeded();
            if (!inList || listLevel !== 2) {
                closeListIfNeeded();
                htmlOutput += '<ol>';
                inList = true;
                listLevel = 2;
            }
            htmlOutput += `<li>${line.substring(line.indexOf('.') + 2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</li>`;
        }
        // Horizontal Rule
        else if (line.trim() === '---') {
            closeListIfNeeded(); closeTableIfNeeded();
            htmlOutput += '<hr class="section-divider">';
        }
        // Paragraphs
        else if (line.trim() !== '') {
            closeListIfNeeded(); closeTableIfNeeded();
            htmlOutput += `<p>${line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`;
        } else {
            closeListIfNeeded();
            if (inTable && !(lines[i+1] && lines[i+1].trim().startsWith('|') && lines[i+1].trim().endsWith('|'))) {
                closeTableIfNeeded();
            }
        }
    }
    closeListIfNeeded();
    closeTableIfNeeded();
    closeAllTocLevels();

    return { htmlOutput, tocHtml };
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    // AJOUTEZ L'INITIALISATION MERMAID AU DÉBUT :
    mermaid.initialize({ 
        startOnLoad: false,
        theme: document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'
    });
    
    const { htmlOutput, tocHtml } = parseMarkdown(markdownContent);
    
    const articleContainer = document.getElementById('article-content-container');
    if (articleContainer) {
        articleContainer.innerHTML = htmlOutput;
        
        // RENDRE LES DIAGRAMMES MERMAID APRÈS INSERTION DU HTML :
        mermaid.run({
            querySelector: '.mermaid'
        });
    }

    const tocContainer = document.getElementById('toc-list-container');
    if (tocContainer) {
        tocContainer.innerHTML = tocHtml;
    }

    // Re-initialize elements dependent on dynamic content
    articleContentSectionForProgress = document.getElementById('article-content-container');
    tocLinks = Array.from(document.querySelectorAll('#toc-list-container .toc-link'));
    sections = Array.from(document.querySelectorAll('#article-content-container h2[id], #article-content-container h3[id], #article-content-container h4[id], #article-content-container h5[id], #article-content-container h6[id]'));
    
    initializeTocLinkSmoothScroll();

    // Initial calls after content is loaded
    updateReadingProgress();
    updateActiveTocLink();
    toggleBackToTop();
    handleResize();
    
    // Initial sidebar state for desktop
    if (window.innerWidth > 1200) {
        if (!navSidebar.classList.contains('open')) {
            navSidebar.classList.add('open');
        }
        mainContent.classList.add('with-sidebar');
    } else {
        mainContent.classList.remove('with-sidebar');
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'T' || e.key === 't')) {
        e.preventDefault();
        themeToggle.click();
    }
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'O' || e.key === 'o')) {
        e.preventDefault();
        tocToggle.click();
    }
});
